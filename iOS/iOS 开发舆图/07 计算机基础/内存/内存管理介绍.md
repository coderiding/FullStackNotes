# 内存管理

- [苹果官方介绍](https://developer.apple.com/videos/play/wwdc2018/416/)

## 内存管理的演进

### 使用物理内存

- 在最开始的时候，程序是直接访问物理内存，但后来有了多程序多任务同时运行，就出现了很多问题。比如，同时运行的程序占用的总内存必须要小于实际物理内存大小。

### 使用虚拟内存

- 程序能够直接访问和修改物理内存，也就能够直接访问和修改其他程序所使用的物理内存，程序运行时的安全就无法保障。
- 由于要解决多程序多任务同时运行的这些问题,所以增加了一个中间层来间接访问物理内存,这个中间层就是虚拟内存。虚拟内存通过映射,可以将虚拟地址转化成物理地址。
- 由于要解决多程序多任务同时运行的这些问题，所以增加了一个中间层来间接访问物理内存，这个中间层就是虚拟内存。虚拟内存通过映射，可以将虚拟地址转化成物理地址。
- 虚拟内存会给每个程序创建一个单独的执行环境，也就是一个独立的虚拟空间，这样每个程序就只能访问自己的地址空间（Address Space)，程序与程序间也就能被安全地隔离开了。
- 32位的地址空间是232=4294967296个字节，共4GB，如果内存没有达到4GB时，虚拟内存比实际的物理内存要大，这会让程序感觉自己能够支配更多的内存。如同虚拟内存只供当前程序使用，操作起来和物理内存一样高效。
- 有了虚拟内存这样一个中间层，极大地节省了物理内存。iOS的共享库就是利用了这一点，只占用一份物理内存，却能够在不同应用的多份虚拟内存中，去使用同一份共享库的物理内存。

### 虚拟内存的问题

- 每个程序都有自己的进程,进程的内存布局主要由代码段、数据段、栈堆组成。程序生成 的汇编代码会放在代码段。如果每个进程的内存布局都是连在一起的话,每个进程分配的空 间就没法灵活变更,栈和堆没用满时就会有很多没用的空间。如果虚拟地址和物理地址的翻 译内存管理单元(Memory Management Unit,MMU)只是简单地通过进程开始地址加上 虚拟地址,来获取物理地址,就会造成很大的内存空间浪费。

## 分段内存

- 分段就是将进程里连在一起的代码段、数据段、栈、堆分开成独立的段,每个段内空间是连 续的,段之间不连续。这样,内存的空间管理MMU就可以更加灵活地进行内存管理
- 那么,段和进程关系是怎么表示的呢?进程中内存地址会用前两个字节表示对应的段。比如 00表示代码段,01标识堆。

### 分段内存的问题

- 段里的进程又是如何管理内存的呢?每个段大增长的方向 Grows Positive也需要记录, 是否可读写也要记录,为的是能够更有效地管理段增长。每个段的大小不一样,在申请的内 存被释放后,容易产生碎片,这样在申请新内存时,很可能就会出现所剩内存空间够用,但 是却不连续,于是造成无法申请的情况。这时,就需要暂停运行进程,对段进行修改,然后 再将内存拷贝到连续的地址空间中。但是,连续拷贝会耗费较多时间。
- 那么,怎么才能降低内存的**碎片化**程度,进而提高性能呢?

## 分页内存

- App在运行时,大多数的时间只会使用很小部分的内存,所以我们可以使用比段粒度更小的 空间管理技术,也就是分页。
- 分页就是把地址空间切分成固定大小的单元这样我们就不用去考虑堆和栈会具体申请多少 空间,而只要考虑需要多少页就可以了。这,对于操作系统管理来说也会简单很多,只需要 维护一份页表(Page TableVirtual Page)和物理页(Physical Page 的关系即可。
- 虚拟页的前两位是vpn(Virtual Page Number),根据页表,翻译为物理地址 PFN(Physical Frame Number).
- 虚拟页与物理页之间的映射关系,就是虚拟内存和物理内存的关系,如下图所示:
- 如图所示,多个进程虚拟页和物理页的关系通过箭头关联起来了,而页表就可以记录下箭头 指向的映射关系。
- 这里,我们需要注意的是,虚拟页和物理页的个数是不一样的。比如,在64位操作系统中 使用的是48位寻址空间,之所以使用48位寻址空间,是因为推出64位系统时硬件还不 能支持64位寻址空间,所以就一直延续下来了虚拟页大小是16K,那么虚拟页最多能有 2^48/2^14=16M个,物理内存为16G对应物理页个数是2^34/2^14=524k个

### 分页存在问题

- 维护虚拟页和物理页关系的页表会随着进程增多而变得越来越大，当页表大于寄存器大小时，就无法放到寄存器中，只能放到内存中。当要通过虚拟地址获取物理地址的时候，就要对页表进行访问翻译，而在内存中进行访问翻译的速度会比CPU的寄存器慢很多。
- 那么，怎么加速页表翻译速度呢?
- 我们知道，缓存可以加速访问。MMU中有一个TLB(Translation-Lookaside Buffer)，可以作为缓存加速访问。所以，在访问页表前，首先检查TLB有没有缓存的虚拟地址对应的物理地址：
- ·如果有的话，就可以直接返回，而不用再去访问页表了；
- ·如果没有的话，就需要继续访问页表。
- 每次都要访问整个列表去查找我们需要的物理地址，终归还是会影响效率，所以又引入了多级页表技术。也就是，根据一定的算法灵活分配多级页表，保证一级页表最小的内存占用。其中，一级页表对应多个二级页表，再由二级页表对应虚拟页。
- 这样内存中只需要保存一级页表就可以，不仅减少了内存占用，而且还提高了访问效率。根据多级页表分配页表层级算法，空间占用多时，页表级别增多，访问页表层级次数也会增多，所以**多级页表机制属于典型的支持时间换空间的灵活方案。**

### 分页管理器

- ios的 XNU Mach Freezer分页器、 VNode分 页器。还有一点需要注意的是,这些分页器不负责调度,调度都是由 Pageout守护线程执 行
- 由于移动设备的内存资源限制,虚拟分页在iOS系统中的控制方式更严格。移动设备的磁盘 空间也不够用,因此没有使用DRAM(动态AM)的方式控制内存。为了减少磁盘空间占 用,ios采用了 Jetsam机制来控制内存的使用。
- 备注:DRAM内存控制方式,是在虚拟页不命中的情况下采用磁盘来缓存。
- 占用内存过多的进程会被强杀,这也就对App占用的内存提出了更高的要求。同时, Jetsam机制也可以避免磁盘和内存交换带来的效率问题,因为磁盘的速度要比DRAM慢上几万倍。

## 内存检测工具

- MLeaksFinder
- FBRetainCycleDetector
- OOMDetector